{
    "docs": [
        {
            "location": "/",
            "text": "Readux\n\n\nReadux is a small, in scope and codebase, library for managing state in web\napplications already using \nreagent\n.\n\n\nReadux is conceptually closest to \nredux\n - and like redux,\nencourages customization and extension through middleware and store enhancers.\n\n\nDocumentation is under construction...\n\n\nThis project is very new and the documentation you see is a first pass - certain examples mentioned in passing\n(handling promises, spec validation, debugger) will become projects in their own right very soon.\n\n\nAlso, if you have a great idea, go ahead and implement it I will happily\nmention your project in the docs :) -- Well, provided it is suitably open\n(e.g. MIT/BSD/Eclipse Public License).\n\n\nShort(ish) description\n\n\nReadux aims to simplify state management by encouraging all state to be managed by a \nstore\n which holds a single entity, which we\ncall the \nmodel\n.\n\n\nThe only way to update the model is to dispatch actions against the store. An action is merely a keyword (e.g. \n:add-todo\n)\nand some (optional) data.\nThe point is for the dispatched actions to describe \nwhat happened\n and have the store contain the logic dictating what to \ndo in response to those actions. This way, we hope to encourage the separation of application logic from the presentation.\n\n\nTo actually handle actions, the store takes a \nreducer\n function, named after the function argument to the \n\nreduce\n function, a reducer is a function which, given an\nan accumulated value (the old model) and some new input (the action) produces a new accumulated value.\n\n\nIn short, a reducer basically has the signature \nreducer: model, action -> new-model\n.\n\n\nTo read from the store, we may either use \nstore->model\n to access to the entire model through a \nreaction\n (think read-only atom)\nor write special named functions called \nqueries\n which we can then use in various reagent components\nto extract data from our model.\n\n\nInspiration\n\n\n\n\nredux\n\n\nThe introduction to reactive programming you've been missing\n\n\nre-frame\n\n\nREADME\n\n\nWIKI: When do components update?\n\n\n\n\n\n\nElm (Lang)\n\n\nElm Tutorial",
            "title": "Home"
        },
        {
            "location": "/#readux",
            "text": "Readux is a small, in scope and codebase, library for managing state in web\napplications already using  reagent .  Readux is conceptually closest to  redux  - and like redux,\nencourages customization and extension through middleware and store enhancers.",
            "title": "Readux"
        },
        {
            "location": "/#documentation-is-under-construction",
            "text": "This project is very new and the documentation you see is a first pass - certain examples mentioned in passing\n(handling promises, spec validation, debugger) will become projects in their own right very soon.  Also, if you have a great idea, go ahead and implement it I will happily\nmention your project in the docs :) -- Well, provided it is suitably open\n(e.g. MIT/BSD/Eclipse Public License).",
            "title": "Documentation is under construction..."
        },
        {
            "location": "/#shortish-description",
            "text": "Readux aims to simplify state management by encouraging all state to be managed by a  store  which holds a single entity, which we\ncall the  model .  The only way to update the model is to dispatch actions against the store. An action is merely a keyword (e.g.  :add-todo )\nand some (optional) data.\nThe point is for the dispatched actions to describe  what happened  and have the store contain the logic dictating what to \ndo in response to those actions. This way, we hope to encourage the separation of application logic from the presentation.  To actually handle actions, the store takes a  reducer  function, named after the function argument to the  reduce  function, a reducer is a function which, given an\nan accumulated value (the old model) and some new input (the action) produces a new accumulated value.  In short, a reducer basically has the signature  reducer: model, action -> new-model .  To read from the store, we may either use  store->model  to access to the entire model through a  reaction  (think read-only atom)\nor write special named functions called  queries  which we can then use in various reagent components\nto extract data from our model.",
            "title": "Short(ish) description"
        },
        {
            "location": "/#inspiration",
            "text": "redux  The introduction to reactive programming you've been missing  re-frame  README  WIKI: When do components update?    Elm (Lang)  Elm Tutorial",
            "title": "Inspiration"
        },
        {
            "location": "/design/",
            "text": "Design Overview\n\n\nThe store & the model\n\n\nReadux aims to simplify state management by encouraging all state to be managed\nby a \nstore\n which holds a single entity, which we call the \nmodel\n.\n\n\nGenerally, we try to \nnormalize\n the data in the model, that is, to organise it\nin such a way, that everything is described just once.\nThis is desirable because a single source of truth means data can't get out of\nsync - we can't have a user profile and the metadata associated a post show\ntwo different profile pictures for the same user - because everything there is\nto know about the user is described \nexactly once\n in our model.\n\n\nActions & Updating the model\n\n\nThe only way to update the model is to dispatch actions against the store.\nAn action is merely a keyword (e.g. \n:add-todo\n) and some (optional) data.\nThe point is for the dispatched actions to describe \nwhat happened\n and have\nthe store contain the logic dictating what to do in response to those actions.\nThis way, we hope to encourage the separation of application logic from the\npresentation.\n\n\nThe store needs some way to handle the actions, to deside how the model \nshould be changed to reflect an \n:add-todo\n action. That's the job of\nthe \nreducer\n function.\nThe reducer takes two arguments, the old model (i.e. the state of our\nentire application as of this moment) and the action, and from these\nconstructs a new model.\nThe only important requirement here is that the reducer is \npure\n, that is,\ngiven the same input, we must always get the same output.\n\n\nGetting data from the model\n\n\nIt's possible to call \nstore->model\n on a store to get a (read-only) atom(1).\nHowever, using that approach is bad for two reasons:\n\n\n1) Every component is now aware of, and \ndepends on\n how our model is structured\n     right now.\n\n\n2) We will quite possibly repeat and re-run code which transforms the raw data\n     into a format suitable for our components.\n\n\nIn readux you're encouraged to use \nqueries\n to extract data from the store and\ntransform it into some format more suitable to for one or more reagent components.\nBy writing these query functions, we solve (1) in that changing the structure of\nthe store only requires rewriting our queries and (2) because each query should\nonly be computed when necessary, more on that later.\n\n\nNotes\n\n\n1) Technically a \nreaction\n - think of it as a atom that can do an arbitrary\n   calculation which is only re-done when the data it depends on changes\n   underneath it. Because we just return the model, it effectively works as\n   a read-only atom.",
            "title": "Design overview"
        },
        {
            "location": "/design/#design-overview",
            "text": "",
            "title": "Design Overview"
        },
        {
            "location": "/design/#the-store-the-model",
            "text": "Readux aims to simplify state management by encouraging all state to be managed\nby a  store  which holds a single entity, which we call the  model .  Generally, we try to  normalize  the data in the model, that is, to organise it\nin such a way, that everything is described just once.\nThis is desirable because a single source of truth means data can't get out of\nsync - we can't have a user profile and the metadata associated a post show\ntwo different profile pictures for the same user - because everything there is\nto know about the user is described  exactly once  in our model.",
            "title": "The store &amp; the model"
        },
        {
            "location": "/design/#actions-updating-the-model",
            "text": "The only way to update the model is to dispatch actions against the store.\nAn action is merely a keyword (e.g.  :add-todo ) and some (optional) data.\nThe point is for the dispatched actions to describe  what happened  and have\nthe store contain the logic dictating what to do in response to those actions.\nThis way, we hope to encourage the separation of application logic from the\npresentation.  The store needs some way to handle the actions, to deside how the model \nshould be changed to reflect an  :add-todo  action. That's the job of\nthe  reducer  function.\nThe reducer takes two arguments, the old model (i.e. the state of our\nentire application as of this moment) and the action, and from these\nconstructs a new model.\nThe only important requirement here is that the reducer is  pure , that is,\ngiven the same input, we must always get the same output.",
            "title": "Actions &amp; Updating the model"
        },
        {
            "location": "/design/#getting-data-from-the-model",
            "text": "It's possible to call  store->model  on a store to get a (read-only) atom(1).\nHowever, using that approach is bad for two reasons:  1) Every component is now aware of, and  depends on  how our model is structured\n     right now.  2) We will quite possibly repeat and re-run code which transforms the raw data\n     into a format suitable for our components.  In readux you're encouraged to use  queries  to extract data from the store and\ntransform it into some format more suitable to for one or more reagent components.\nBy writing these query functions, we solve (1) in that changing the structure of\nthe store only requires rewriting our queries and (2) because each query should\nonly be computed when necessary, more on that later.",
            "title": "Getting data from the model"
        },
        {
            "location": "/design/#notes",
            "text": "1) Technically a  reaction  - think of it as a atom that can do an arbitrary\n   calculation which is only re-done when the data it depends on changes\n   underneath it. Because we just return the model, it effectively works as\n   a read-only atom.",
            "title": "Notes"
        },
        {
            "location": "/reference/",
            "text": "Reference\n\n\nAction\n\n\nActions in readux follow the structure of \nflux standard actions (FSA)\n.\n\n\nAn FSA-action must not have any keys beside \n:type\n, \n:payload\n, \n:error\n and \n:meta\n, and only\n\n:type\n is required.\n\n\n\n\n:type\n- the type of the action, e.g. \n:add-todo\n, \n:show-editor\n\n\n:payload\n - any data which should be sent along with the action.\n\n\n:error\n\n\noptional boolean field\n\n\nanalguous to a rejected promise (i.e. processing the action failed at some step). \n\n\nIf \n:error\n is set, the \n:payload\n should contain an error object describing what went wrong.\n\n\n\n\n\n\n:meta\n \n\n\nintended to hold data not directly pertaining to the action.\n\n\n\n\n\n\n\n\n;; Example action.\n{:type :add-todo\n :payload \"Buy milk\"}\n\n\n\n\nThis might seem constricting, but having a standard format makes it simpler to write\nmiddleware and store enhancers which work on actions - and ultimately makes readux \nsimpler to use since middleware becomes more readily composable.\n\n\nAction Maps\n\n\nReducers, covered in detail below, act on the model in response to incoming actions.\n\n\nTo do that, the reducer will accept a map, which map actions (by their type) to\na corresponding function. Think of an action map as a series of \"if X, then do Y\".\nIf this seems\n\n\nSuppose our application has a counter which can be incremented or decremented\nby one - the application's model looks like so:\n\n\n{:counter 0}\n\n\n\n\nAsuming we name the increment and decrement actions \n:increment\n and \n:decrement\n\nrespectively, our action map would look something like this:\n\n\n{:increment\n (fn [model action]\n   (update model :counter inc))\n :decrement\n (fn [model action]\n   (update model :counter dec))}\n\n\n\n\nTip: Reuse your action maps!\n\n\nIt will take a while to fully appreciate, but wrapping our actions into a map\nwill prove helpful later when building reducers and later still when making\nsets of components to be reused across the application.\n\n\nImagine two forms sharing \n\n\n, as can be merged (allowing \nreuse of identical subsets of functionality) and their keys can be mangled\nto contextualize actions - meaning not all counters are updated whenever\nan \n:increment\n action is dispatched.\n\n\nReducer\n\n\nSignature:\n \nmodel, action -> new-model\n\n\nA reducer is a function which takes a model and some action, producing from\nthem a new model. This might sound complex, but it's actually not, it works\nexactly like \n(reduce + 0 [1 2 3 4])\n. The result of \nreduce\n, \n10\n in \nthis case, is the result of continuously using the \n+\n function on the\nprevious result and the next value in line - and that's exactly how the\nreducer function is meant to work.\n\n\nBecause of the way reducers can be composed together, there's a few requirements\nwhich a reducer must meet:\n\n\n\n\nPurity\n - Given the same input (model & action) the reducer must always produce the same result\n\n\nHandle nil input\n - When the first action is dispatched, the model is initially empty. The reducer must treat a nil-value for a model as a queue to initilize it.\n\n\nReturn a model\n - If an action doesn't apply to the reducer, simply return the model as it was.\n\n\n\n\nIt turns out that obeying these rules means we can build reducers which\ndelegates parts of their model to other reducers. But first, let's see\na simple reducer:\n\n\nWriting simple reducers\n\n\nHere's a small example reducer for a counter:\n\n\n(defn counter-reducer \n  [model action]\n  (let [model (or model {:value 0})] ;; initialize if needed\n    (case (:type action)\n      :increment (update model :value inc)\n      :decrement (update model :value dec)\n      model))) ;; return model (i.e. no change) as a fall-back\n\n\n\n\nNotice how the original model is returned if the action was neither \n\n:increment\n nor \n:decrement\n. Also notice how \nmodel\n is initialised if a nil\nvalue is received.\n\n\nReducers of this kind are common, that's why readux provides \nreducer\n to\nhelp writing reducers which handle requirements 2 & 3.\n\n\n(def counter-reducer\n  (rdc/reducer\n    {:value 0}\n    {:increment (fn [model action]\n                  (update model :value inc))\n     :decrement (fn [model action]\n                  (update model :value dec))}))\n\n\n\n\nCombining reducers\n\n\nLet's assume we're making a simple todo application.\n\n\nAssume we want to build a todo application. We might want two reducers, one\nmanaging a list of todos (each represented as a map) and another managing\na display filter - which allows us to display all, only completed or active\ntodos.\n\n\n(def todo-reducer\n  (rdc/reducer\n  {:todos [{:id 1\n            :text \"read the readux tutorial\"\n            :completed false}]}\n  todo-actions))\n\n(def filter-reducer\n  (rdc/reducer\n  :show-all\n  filter-actions))\n\n\n\n\nA composite reducer\n\n\nLet's say we want the model state to look like so:\n\n\n{:todos [{:id 1\n          :text \"read readux tutorial\"\n          :completed false}]\n :filter :show-all}\n\n\n\n\nWhile we could rewrite our two reducers into one big reducer, manually handling\nthe creation of the nested map that is our model, that would be wasted effort.\n\n\nInstead, we can make a reducer, which is the two other reducers composed:\n\n\n(def app-reducer\n  (rdc/composite-reducer\n    {:todos  todo-reducer\n     :filter filter-reducer}))\n\n\n\n\nA composite reducer - described as data\n\n\ncomposite-reducer\n also allows you to forego defining each individual reducer.\nAfter all, reducers just require an initial model and a set of actions. So we\ncould also define our composite reducer like so:\n\n\n(def app-reducer\n  (rdc/composite-reducer\n    {:todos  {:init {:todos []\n                     :filter :show-all}\n              :actions todo-actions}\n     :filter {:init :show-all\n              :actions filter-actions}}))\n\n\n\n\nThis turns out to be especially helpful in larger apps where the app reducer\nconsists of many smaller reducers composed together.\n\n\nNested Composite Reducers\n\n\nThe result of calling \ncomposite-reducer\nis itself a reducer, so it's possible\nto keep nesting reducers as desired. However, having these strewn about as\nseparate \ndef\n's in our source-code makes it difficult to see which part of the\nmodel they manage.\n\n\nHowever, \ncomposite-reducer\n allows you to write a deeply nested tree of\nreducers as one big map - making it much easier to visually discern which part\nof the model a given reducer manages.\n\n\nLet's assume we wanted to expand our todo app to managing multiple todo lists,\none for each project. In that case, we may want the state to be:\n\n\n{:projects\n {:work\n  {:label \"Work Todos\"\n   :todos\n   [{:id 1\n     :text \"read readux tutorial\"\n     :completed false}]\n   :filter :show-all}\n  :home\n  {:label \"House Chores\"\n   :todos\n   [{:id 1\n     :text \"locate source of smell in the fridge\"\n     :completed false}]\n   :filter :show-active}}\n :filter #(:work :home)}\n\n\n\n\nWith \ncomposite-reducer\n we can express that like so:\n\n\n(def app-reducer\n  (rdc/composite-reducer\n    {:projects\n     {:work {:init todo-model\n             :actions todo-actions\n             :ctx :work}\n      :home {:init todo-model\n             :actions todo-actions\n             :ctx :home}}\n     :filter project-filter-reducer}))\n\n\n\n\ncomposite-reducer\n automatically recognizes that the map supplied to \n:projects\n\nisn't meant to be a reducer (it's lacking \n:init\n & \n:actions\n) - so it treats\nit as a composite reducer in its own right.\n\n\nNote that you can take this as far as you want, and note how our app's reducer\nvisually resembles the model we want it to manage :)\n\n\nYou may have noticed the \n:ctx\n key in both maps describing the reducers for\nthe work- and personal todo-lists.\nContext essentially allows use to reuse the same actions and components in a\ndifferent part of the application (\ncontext\n) and is a mechanism for\nfacilitating reuse.\n\n\nQuery\n\n\nConsider a blog post which shows the name, a blurp and a profile picture of the\nauthor - we don't wan't to store this with every post - we want a single source\nof truth such that a new profile picture requires one change to be reflected\nacross the page.\nThat means we'll tend to normalize our data and have a model like so:\n\n\n{:users {0 {:name \"Bob\"\n            :avatar \"http......\"}\n         1 {:name \"Sarah\"\n            :avatar \"http......\"}}\n :posts {100 {:author 0\n              :title \"On the duplicitous nature of cats\"\n              :text \"....\"}\n         101 {:author 1\n              :title \"Monads are for newbs\"\n              :text \"....\"}\n         102 {:author 1\n              :title \"Winter 2016 Anime List\"\n              :text \"...\"}}}\n\n\n\n\nIn Readux, you're encouraged to use \nqueries\n, which are functions operating\non the store, producing some output which fits the needs of one or some \ncomponents.\n\n\nUsing queries\n\n\nE.g., for our posts component, we might have a query 'fetch-post <id>'\nwhich produces:\n\n\n(rdc/query store [:fetch-post 101])\n;;=>\n{:author {:name \"Sarah\"\n          :avatar \"http....\"}\n :id 101\n :title \"Monads are for newbs\"\n :text \"\"}\n\n\n\n\nThat is, queries are used to:\n\n\n\n\nAvoid coupling the structure of the store to each component which reads from it\n\n\nAvoid re-running the computation required to transform the data more often than necessary (i.e. run when the model changes).\n\n\n\n\nWriting queries\n\n\nContinuing from the example above, let's actually implement it. Adding a new\nquery takes two steps; defining the query function and registering it with the\nstore.\n\n\nWriting the query function\n\n\n;; Example: defining the `post` query.\n(defn post-query\n  [model [query-id post-id]]\n  (assert (= query-id :fetch-post))\n  (let [users (reaction (:users @model))\n        posts (reaction (:posts @model))]\n    (-> (get @posts post-id)\n        (update :author #(get @users %))\n        (reaction))))\n\n\n\n\nNotice how we start by extracting two smaller parts of the model, \n:users\n and\n\n:posts\n from the model into separate reactions before transforming the data\ninto the form we'd like to use.\nThis leverages the nature of reactions to ensure our query is only re-run if\nthe content of the \n:posts\n or \n:users\n fields change - in this way, we can\nscale our queries to work well even in applications with a gigantic model which\ngets updated very frequently. Our query only gets re-run when the subtrees\n\n:posts\n or \n:users\n change in the model.\n\n\nThis example is somewhat contrived; our query is simple and it likely won't\nmatter much. The point, however, is that expensive queries such as sorting a\nset of items or say, rendering post content stored as markdown into HTML,\ncan be tweaked to run only when necessary by making them depend on\nreactions which expose only the data they should operate on.\n\n\nRegistering the query with the store\n\n\nSecondly, the query needs to be registered with the store:\n\n\n;; Registering the 'post' query with the store.\n(rdc/query-reg! store :post fetch-post-query)\n\n\n\n\nNotice how we register the query under an id (in this case, \n:post\n). This is\nthe id we use to refer to the query from within our components when we\nwrite something like \n(rdc/query store [:fetch-post 101])\n.\n\n\nBecause you typically want to register a lot of queries right away, readux\nprovides a helper function, \nqueries-reg!\n:\n\n\n(queries-reg! {:post post-query\n               :posts posts-index-query})\n\n\n\n\nContext - reusing work\n\n\nSometimes we create a piece of functionality which we'd like to reuse in\ndifferent parts of the application.Examples would be a standardized yes/no\nmodal, a document editor, or maybe just a nicely styled drop-down menu with\nfuzzy search completion.\n\n\nIn traditional GUI-frameworks, larger composite widgets could be made from\nsmaller base-widgets, their internal events properly connected and exposed\nas a single widget.\n\n\nReadux allows the same style of reuse through the concept of \ncontext\n.\nContextualising does two things:\n\n\n\n\non dispatch, actions whose type lack a context, are prefixed with the context\n\n\ne.g. given context \n:work-list\n, \n:add-todo\n becomes \n:work-list/add-todo\n.\n\n\nNOTE: already contextualized actions, e.g. \n:app/login\n won't be altered.\n\n\n\n\n\n\nqueries lacking a context, are prefixed with the context\n\n\ne.g. given context \n:work-list\n, \n:todos\n becomes \n:work-list/todos\n.\n\n\nNOTE: already contextualized queries, e.g. \n:projects/list\n, won't be altered.\n\n\n\n\n\n\n\n\nThink of action types and query id's as akin to pathnames on a unix system.\nIf the keyword lacks a namespace, they are \nrelative\n to whatever context the\ncomponent is used in.\nIf the keyword has a namespace, it's like an absolute path and will resolve\nto the same thing regardless of the context in which the component is used.\n\n\nTo accomplish this, the \nquery\n and \ndispatch\n functions are passed directly to\nthe component. The interface mirrors their respective functions except the\n\nstore\n argument is omitted.\n\n\nIt's perfectly possible to write reusable components without contextualising\nthem. Though if you do so, your components will need to receive a series of\ncallbacks for the dispatches and queries needed.\nThe drawback of that model is most noticable when components are nested in\neachother, though for relatively simple, flat components, it's a viable\nalternative.\n\n\nContextualising a component\n\n\nTo contextualize a component, use \nreadux.core/connect\n. \nconnect\n takes\na component, a store, the context and a path into the model.\n\n\nNote that readux doesn't enforce any link between context and path into\nthe model - different reducers, and thus different parts of the model,\nmay want to react to the same action.\n\n\nHowever, you generally want to ensure that the path to the reducer reacting\nto (the contextualized) actions dispatched from the component matching the\npath given to the connected component.  \n\n\n;; Connect component 'counter-ctrl' to context ':counter1' operating\n;; on the data (get-in model [:counters :1])\n(rdc/connect counter-ctrl store :counter1 [:counters :1])\n\n\n\n\nExample - multiple counters\n\n\nThe code snippets below are extracted from the readux \"counter\" example.\n\n\nExamine the \nfull source\n,\ncheck it out and issue \nboot dev\n to run it. Keep in mind, the example\ncontains additional comments.\n\n\nGiven a reducer managing two counters:\n\n\n(def app-reducer\n  (rdc/composite-reducer\n    {:counters\n     {:1 {:init {:counter 11}\n          :actions counter-actions\n          :ctx :counter1}\n      :2 {:init {:counter 20}\n          :actions counter-actions\n          :ctx :counter2}}\n     :num-actions num-actions-reducer}))\n\n\n\n\nWe create a controller component, that is, a component wires up our\npresentational component(s) to our application logic. In this case\nby making some action dispatch and query callbacks.\n\n\n(defn counter-ctrl\n  [dispatch query]\n  (let [value (query [:counter-value])\n        on-inc #(dispatch {:type :incr})\n        on-dec #(dispatch {:type :decr})]\n    [counter value on-inc on-dec]))\n\n\n\n\nFinally, we connect two counters to different contexts and display them both:\n\n\n(defn- app\n  [store]\n  (let [counter1 (rdc/connect counter-ctrl store :counter1 [:counters :1])\n        counter2 (rdc/connect counter-ctrl store :counter2 [:counters :2])\n        num-actions (rdc/query store [:num-actions])]\n    (fn app-render []\n      [:div\n       [counter1]\n       [counter2]\n       [:p (str \"processed '\" @num-actions \"' actions so far.\")]])))",
            "title": "Reference Documentation"
        },
        {
            "location": "/reference/#reference",
            "text": "",
            "title": "Reference"
        },
        {
            "location": "/reference/#action",
            "text": "Actions in readux follow the structure of  flux standard actions (FSA) .  An FSA-action must not have any keys beside  :type ,  :payload ,  :error  and  :meta , and only :type  is required.   :type - the type of the action, e.g.  :add-todo ,  :show-editor  :payload  - any data which should be sent along with the action.  :error  optional boolean field  analguous to a rejected promise (i.e. processing the action failed at some step).   If  :error  is set, the  :payload  should contain an error object describing what went wrong.    :meta    intended to hold data not directly pertaining to the action.     ;; Example action.\n{:type :add-todo\n :payload \"Buy milk\"}  This might seem constricting, but having a standard format makes it simpler to write\nmiddleware and store enhancers which work on actions - and ultimately makes readux \nsimpler to use since middleware becomes more readily composable.",
            "title": "Action"
        },
        {
            "location": "/reference/#action-maps",
            "text": "Reducers, covered in detail below, act on the model in response to incoming actions.  To do that, the reducer will accept a map, which map actions (by their type) to\na corresponding function. Think of an action map as a series of \"if X, then do Y\".\nIf this seems  Suppose our application has a counter which can be incremented or decremented\nby one - the application's model looks like so:  {:counter 0}  Asuming we name the increment and decrement actions  :increment  and  :decrement \nrespectively, our action map would look something like this:  {:increment\n (fn [model action]\n   (update model :counter inc))\n :decrement\n (fn [model action]\n   (update model :counter dec))}",
            "title": "Action Maps"
        },
        {
            "location": "/reference/#tip-reuse-your-action-maps",
            "text": "It will take a while to fully appreciate, but wrapping our actions into a map\nwill prove helpful later when building reducers and later still when making\nsets of components to be reused across the application.  Imagine two forms sharing   , as can be merged (allowing \nreuse of identical subsets of functionality) and their keys can be mangled\nto contextualize actions - meaning not all counters are updated whenever\nan  :increment  action is dispatched.",
            "title": "Tip: Reuse your action maps!"
        },
        {
            "location": "/reference/#reducer",
            "text": "Signature:   model, action -> new-model  A reducer is a function which takes a model and some action, producing from\nthem a new model. This might sound complex, but it's actually not, it works\nexactly like  (reduce + 0 [1 2 3 4]) . The result of  reduce ,  10  in \nthis case, is the result of continuously using the  +  function on the\nprevious result and the next value in line - and that's exactly how the\nreducer function is meant to work.  Because of the way reducers can be composed together, there's a few requirements\nwhich a reducer must meet:   Purity  - Given the same input (model & action) the reducer must always produce the same result  Handle nil input  - When the first action is dispatched, the model is initially empty. The reducer must treat a nil-value for a model as a queue to initilize it.  Return a model  - If an action doesn't apply to the reducer, simply return the model as it was.   It turns out that obeying these rules means we can build reducers which\ndelegates parts of their model to other reducers. But first, let's see\na simple reducer:",
            "title": "Reducer"
        },
        {
            "location": "/reference/#writing-simple-reducers",
            "text": "Here's a small example reducer for a counter:  (defn counter-reducer \n  [model action]\n  (let [model (or model {:value 0})] ;; initialize if needed\n    (case (:type action)\n      :increment (update model :value inc)\n      :decrement (update model :value dec)\n      model))) ;; return model (i.e. no change) as a fall-back  Notice how the original model is returned if the action was neither  :increment  nor  :decrement . Also notice how  model  is initialised if a nil\nvalue is received.  Reducers of this kind are common, that's why readux provides  reducer  to\nhelp writing reducers which handle requirements 2 & 3.  (def counter-reducer\n  (rdc/reducer\n    {:value 0}\n    {:increment (fn [model action]\n                  (update model :value inc))\n     :decrement (fn [model action]\n                  (update model :value dec))}))",
            "title": "Writing simple reducers"
        },
        {
            "location": "/reference/#combining-reducers",
            "text": "Let's assume we're making a simple todo application.  Assume we want to build a todo application. We might want two reducers, one\nmanaging a list of todos (each represented as a map) and another managing\na display filter - which allows us to display all, only completed or active\ntodos.  (def todo-reducer\n  (rdc/reducer\n  {:todos [{:id 1\n            :text \"read the readux tutorial\"\n            :completed false}]}\n  todo-actions))\n\n(def filter-reducer\n  (rdc/reducer\n  :show-all\n  filter-actions))",
            "title": "Combining reducers"
        },
        {
            "location": "/reference/#a-composite-reducer",
            "text": "Let's say we want the model state to look like so:  {:todos [{:id 1\n          :text \"read readux tutorial\"\n          :completed false}]\n :filter :show-all}  While we could rewrite our two reducers into one big reducer, manually handling\nthe creation of the nested map that is our model, that would be wasted effort.  Instead, we can make a reducer, which is the two other reducers composed:  (def app-reducer\n  (rdc/composite-reducer\n    {:todos  todo-reducer\n     :filter filter-reducer}))",
            "title": "A composite reducer"
        },
        {
            "location": "/reference/#a-composite-reducer-described-as-data",
            "text": "composite-reducer  also allows you to forego defining each individual reducer.\nAfter all, reducers just require an initial model and a set of actions. So we\ncould also define our composite reducer like so:  (def app-reducer\n  (rdc/composite-reducer\n    {:todos  {:init {:todos []\n                     :filter :show-all}\n              :actions todo-actions}\n     :filter {:init :show-all\n              :actions filter-actions}}))  This turns out to be especially helpful in larger apps where the app reducer\nconsists of many smaller reducers composed together.",
            "title": "A composite reducer - described as data"
        },
        {
            "location": "/reference/#nested-composite-reducers",
            "text": "The result of calling  composite-reducer is itself a reducer, so it's possible\nto keep nesting reducers as desired. However, having these strewn about as\nseparate  def 's in our source-code makes it difficult to see which part of the\nmodel they manage.  However,  composite-reducer  allows you to write a deeply nested tree of\nreducers as one big map - making it much easier to visually discern which part\nof the model a given reducer manages.  Let's assume we wanted to expand our todo app to managing multiple todo lists,\none for each project. In that case, we may want the state to be:  {:projects\n {:work\n  {:label \"Work Todos\"\n   :todos\n   [{:id 1\n     :text \"read readux tutorial\"\n     :completed false}]\n   :filter :show-all}\n  :home\n  {:label \"House Chores\"\n   :todos\n   [{:id 1\n     :text \"locate source of smell in the fridge\"\n     :completed false}]\n   :filter :show-active}}\n :filter #(:work :home)}  With  composite-reducer  we can express that like so:  (def app-reducer\n  (rdc/composite-reducer\n    {:projects\n     {:work {:init todo-model\n             :actions todo-actions\n             :ctx :work}\n      :home {:init todo-model\n             :actions todo-actions\n             :ctx :home}}\n     :filter project-filter-reducer}))  composite-reducer  automatically recognizes that the map supplied to  :projects \nisn't meant to be a reducer (it's lacking  :init  &  :actions ) - so it treats\nit as a composite reducer in its own right.  Note that you can take this as far as you want, and note how our app's reducer\nvisually resembles the model we want it to manage :)  You may have noticed the  :ctx  key in both maps describing the reducers for\nthe work- and personal todo-lists.\nContext essentially allows use to reuse the same actions and components in a\ndifferent part of the application ( context ) and is a mechanism for\nfacilitating reuse.",
            "title": "Nested Composite Reducers"
        },
        {
            "location": "/reference/#query",
            "text": "Consider a blog post which shows the name, a blurp and a profile picture of the\nauthor - we don't wan't to store this with every post - we want a single source\nof truth such that a new profile picture requires one change to be reflected\nacross the page.\nThat means we'll tend to normalize our data and have a model like so:  {:users {0 {:name \"Bob\"\n            :avatar \"http......\"}\n         1 {:name \"Sarah\"\n            :avatar \"http......\"}}\n :posts {100 {:author 0\n              :title \"On the duplicitous nature of cats\"\n              :text \"....\"}\n         101 {:author 1\n              :title \"Monads are for newbs\"\n              :text \"....\"}\n         102 {:author 1\n              :title \"Winter 2016 Anime List\"\n              :text \"...\"}}}  In Readux, you're encouraged to use  queries , which are functions operating\non the store, producing some output which fits the needs of one or some \ncomponents.",
            "title": "Query"
        },
        {
            "location": "/reference/#using-queries",
            "text": "E.g., for our posts component, we might have a query 'fetch-post <id>'\nwhich produces:  (rdc/query store [:fetch-post 101])\n;;=>\n{:author {:name \"Sarah\"\n          :avatar \"http....\"}\n :id 101\n :title \"Monads are for newbs\"\n :text \"\"}  That is, queries are used to:   Avoid coupling the structure of the store to each component which reads from it  Avoid re-running the computation required to transform the data more often than necessary (i.e. run when the model changes).",
            "title": "Using queries"
        },
        {
            "location": "/reference/#writing-queries",
            "text": "Continuing from the example above, let's actually implement it. Adding a new\nquery takes two steps; defining the query function and registering it with the\nstore.",
            "title": "Writing queries"
        },
        {
            "location": "/reference/#writing-the-query-function",
            "text": ";; Example: defining the `post` query.\n(defn post-query\n  [model [query-id post-id]]\n  (assert (= query-id :fetch-post))\n  (let [users (reaction (:users @model))\n        posts (reaction (:posts @model))]\n    (-> (get @posts post-id)\n        (update :author #(get @users %))\n        (reaction))))  Notice how we start by extracting two smaller parts of the model,  :users  and :posts  from the model into separate reactions before transforming the data\ninto the form we'd like to use.\nThis leverages the nature of reactions to ensure our query is only re-run if\nthe content of the  :posts  or  :users  fields change - in this way, we can\nscale our queries to work well even in applications with a gigantic model which\ngets updated very frequently. Our query only gets re-run when the subtrees :posts  or  :users  change in the model.  This example is somewhat contrived; our query is simple and it likely won't\nmatter much. The point, however, is that expensive queries such as sorting a\nset of items or say, rendering post content stored as markdown into HTML,\ncan be tweaked to run only when necessary by making them depend on\nreactions which expose only the data they should operate on.",
            "title": "Writing the query function"
        },
        {
            "location": "/reference/#registering-the-query-with-the-store",
            "text": "Secondly, the query needs to be registered with the store:  ;; Registering the 'post' query with the store.\n(rdc/query-reg! store :post fetch-post-query)  Notice how we register the query under an id (in this case,  :post ). This is\nthe id we use to refer to the query from within our components when we\nwrite something like  (rdc/query store [:fetch-post 101]) .  Because you typically want to register a lot of queries right away, readux\nprovides a helper function,  queries-reg! :  (queries-reg! {:post post-query\n               :posts posts-index-query})",
            "title": "Registering the query with the store"
        },
        {
            "location": "/reference/#context-reusing-work",
            "text": "Sometimes we create a piece of functionality which we'd like to reuse in\ndifferent parts of the application.Examples would be a standardized yes/no\nmodal, a document editor, or maybe just a nicely styled drop-down menu with\nfuzzy search completion.  In traditional GUI-frameworks, larger composite widgets could be made from\nsmaller base-widgets, their internal events properly connected and exposed\nas a single widget.  Readux allows the same style of reuse through the concept of  context .\nContextualising does two things:   on dispatch, actions whose type lack a context, are prefixed with the context  e.g. given context  :work-list ,  :add-todo  becomes  :work-list/add-todo .  NOTE: already contextualized actions, e.g.  :app/login  won't be altered.    queries lacking a context, are prefixed with the context  e.g. given context  :work-list ,  :todos  becomes  :work-list/todos .  NOTE: already contextualized queries, e.g.  :projects/list , won't be altered.     Think of action types and query id's as akin to pathnames on a unix system.\nIf the keyword lacks a namespace, they are  relative  to whatever context the\ncomponent is used in.\nIf the keyword has a namespace, it's like an absolute path and will resolve\nto the same thing regardless of the context in which the component is used.  To accomplish this, the  query  and  dispatch  functions are passed directly to\nthe component. The interface mirrors their respective functions except the store  argument is omitted.  It's perfectly possible to write reusable components without contextualising\nthem. Though if you do so, your components will need to receive a series of\ncallbacks for the dispatches and queries needed.\nThe drawback of that model is most noticable when components are nested in\neachother, though for relatively simple, flat components, it's a viable\nalternative.",
            "title": "Context - reusing work"
        },
        {
            "location": "/reference/#contextualising-a-component",
            "text": "To contextualize a component, use  readux.core/connect .  connect  takes\na component, a store, the context and a path into the model.  Note that readux doesn't enforce any link between context and path into\nthe model - different reducers, and thus different parts of the model,\nmay want to react to the same action.  However, you generally want to ensure that the path to the reducer reacting\nto (the contextualized) actions dispatched from the component matching the\npath given to the connected component.    ;; Connect component 'counter-ctrl' to context ':counter1' operating\n;; on the data (get-in model [:counters :1])\n(rdc/connect counter-ctrl store :counter1 [:counters :1])",
            "title": "Contextualising a component"
        },
        {
            "location": "/reference/#example-multiple-counters",
            "text": "The code snippets below are extracted from the readux \"counter\" example.  Examine the  full source ,\ncheck it out and issue  boot dev  to run it. Keep in mind, the example\ncontains additional comments.  Given a reducer managing two counters:  (def app-reducer\n  (rdc/composite-reducer\n    {:counters\n     {:1 {:init {:counter 11}\n          :actions counter-actions\n          :ctx :counter1}\n      :2 {:init {:counter 20}\n          :actions counter-actions\n          :ctx :counter2}}\n     :num-actions num-actions-reducer}))  We create a controller component, that is, a component wires up our\npresentational component(s) to our application logic. In this case\nby making some action dispatch and query callbacks.  (defn counter-ctrl\n  [dispatch query]\n  (let [value (query [:counter-value])\n        on-inc #(dispatch {:type :incr})\n        on-dec #(dispatch {:type :decr})]\n    [counter value on-inc on-dec]))  Finally, we connect two counters to different contexts and display them both:  (defn- app\n  [store]\n  (let [counter1 (rdc/connect counter-ctrl store :counter1 [:counters :1])\n        counter2 (rdc/connect counter-ctrl store :counter2 [:counters :2])\n        num-actions (rdc/query store [:num-actions])]\n    (fn app-render []\n      [:div\n       [counter1]\n       [counter2]\n       [:p (str \"processed '\" @num-actions \"' actions so far.\")]])))",
            "title": "Example - multiple counters"
        },
        {
            "location": "/extending/",
            "text": "Extending Readux\n\n\nThis document assumes familiarity with what's written intended\nthe \ndesign overview\n and \nreference\n pages, \nwhich explain the rationale and introduces core terminology.\n\n\nOf libraries and frameworks\n\n\nreadux, like \nredux\n, is a fairly unopinionated \nlibrary\n. \nLibraries are limited in scope whereas frameworks are cohesive, thoughtful, but\n\nprescriptive\n solutions to a set of problems.\nFrameworks are a great thing when your use-case aligns perfectly with\nwhat the authors intended - less so when you're fighting them to achieve\nsomething not envisioned or catered to.\n\n\nConversely, libraries are concerned with solving a relatively small problem\nand you're left to assemble the libraries needed to solve your problem.\nThe upside is that you can tailor a solution matching the problem.\n\n\nFor example, the Redux community has multiple takes on managing async\nrequests, from \nthunks\n to \n\npromises\n through \n\ngenerators\n.\nThere is no universal, \nright\n (\n) solution - the best approach is relative\nto the scale and complexity of your application. \nEven if there were, using a set of libraries means that once some superior\napproach to solving the problem comes along, you can swap out a library\ninstead of starting all over in a new framework.\n\n\nIn summary, readux doesn't do much, but it's designed to play well with\nother libraries, and that's a good thing(\n).\n\n\nHow to extend readux\n\n\nIn concrete terms, readux allows writing \nstore enhancers\n augment the store,\nadding additional functionality like 'queries', debuggers etc and \nmiddleware\n,\nwhich sits between the call dispatching an action and it being forwarded to the\nreducer.\nGenerally, if you mean to simply alter actions on a case-by-case (pure) basis,\nmiddleware will do. If you need to retain some state, e.g. to store a map of\nregistered queries or data related to a debugger, then writing a store enhancer\nis the way to go.\n\n\nMiddleware\n\n\nMiddleware is used whenever you wish to automatically do something\nbefore an action reaches your store's root reducer or before the\nresulting model is persisted.\n\n\nExample: Handling Promises\n\n\nSay we wanted to automatically process incoming actions which submits a\npromise as their argument, splitting the action \n:fetch-posts\n into \n\n:fetch-posts.rq\n, \n:fetch-posts.success\n and \n:fetch-posts.error\n to signify\nwhen the request is made, and when it ends in a success or an error,\nrespectively. We could wrap this process ourselves for each async request our\napplication would make, or write a piece of middleware to handle promises for us.\n\n\nIncidentially, if you wish to do this, or already use \npromesa\n,\ntry \nreadux-promesa\n.\n\n\nExample: Verifying app model with cljs.spec\n\n\nSimilarly, if you wished to ensure that for each action, the model\nretained some specific structure, you could implement a middleware function\nto validate the resulting model against a clojure.spec schema.\n\n\nWriting middleware\n\n\nSignature:\n \nnext -> model, action -> new-model\n\n\nWe see from the signature that middleware takes a single argument '\nnext\n', which\nis the middleware/reducer function to execute next. From this, we get a function,\nwhich, when given a '\nmodel\n' and an '\naction\n', yields a new model which is the\nresult of applying the action to the old model.\n\n\n;; This middleware does nothing but pass the action along.\n(defn passthrough-middleware\n  [next]\n  (fn [model action]\n    (apply next model action)))\n\n\n\n\nOften times, you only need to do something to an action or in response to\nan action \nbefore\n it is received by the reducer, but sometimes it can\nbe handy to work on the resulting model too.\n\n\nReadux ships with a middleware function, \nlog-model-diff\n which can show you\nevery action that is dispatched and how it changed the model. \n\nlog-model-diff\n stores a copy of the model before passing it on to the next\nmiddleware function in the chain, ideally the reducer itself, comparing the \nresulting model to the initial model.\nTry reading its \nsource\n\nfor inspiration on writing your own middleware functions.\n\n\nRemember, middleware functions can:\n\n\n\n\nprematurely abort processing simply by not calling the next function in line.\n\n\nalter/replace and dispatch additional actions. \n\n\n(see \nreadux-promesa\n which uses this to handle promises)\n\n\n\n\n\n\nalter/replace the input model before passing it on to the next function\n\n\nalter/replace the new model before returning it to the caller (ultimately the \ndispatch\n function, which stores the new model)\n\n\n\n\nUsing middleware\n\n\nTo use middleware, we supply \nstore\n with an optional second argument\nwhich modifies the construction of the store somehow before it is\nreturned to us.\n\n\nIn this case, using \napply-mw\n allows us to install an arbitrary sequence\nof functions in between \ndispatch\n which first receives and action, and\nthe store's reducer function. Here's an example:\n\n\n(require '[readux.core :as rdc])\n(require '[readux.store :as rds])\n;; ...\n(defonce store (rdc/store app-reducer (rds/apply-mw some-other-middleware log-model-diff)))\n\n\n\n\nIn this case, the action will go through the system like so:\n\n\n\n\ndispatch\n this is when the action is first dispatched \n\n\nsome-other-middleware\n\n\nlog_model_diff\n\n\napp-reducer\n - the application's reducer function.\n\n\n\n\nStore enhancers\n\n\nSignature:\n \nstore -> store\n\n\nStore enhancers, as their name implies, modify the store object itself. Generally, store enhancers should be used when\nmiddleware won't suffice, such as when new functionality relying on additional fields in the store object is implemented.\n\n\nExample: readux-debugger\n\n\nFor example, the readux-debugger creates an additional store, tied to the app-store which controls its own model and which\nhas its own reducer. By enhancing the store, it can replace the standard dispatch-function invoked when an action is \ndispatched.\nThe dispatch function normally finds the store's reducer, and passes along the action, storing the value returned as the\nnew model.\nBy replacing the dispatcher, the readux-debugger can intercept and assure that debug-related actions never reach the\napp reducer while ensuring app-related actions are dispatched to both the debugger and app stores.\n\n\n(\nNOTE\n not presently released, coming soon)\n\n\nWriting Store Enhancers\n\n\nThe smallest possible example is also a bit silly, typically you want to wrap the \n:dispatch\n function or add some\nadditional entries to facilitate some expanded interface.\n\n\n(defn make-stores-great-again\n  [app-store]\n  (swap! app-store assoc :is-great? true))\n\n\n\n\nWith our additional data, we can implement new store functions, such as this:\n\n\n(defn great-store?\n  [store] \n  (get @store :is-great? false))\n\n\n\n\nThe ability for a store to use middleware functions is actually implemented as\na store enhancer, see \napply-mw\n in \nreadux store.cljs\n.\n\n\nUsing Store Enhancers\n\n\nThe store function accepts an additional argument, allowing you to specify an enhancer function.\nTo use multiple store enhancers, use \ncomposition\n.\n\n\n(def s (store my-reducer make-stores-great-again))\n(great-store? s)\n;;=> true",
            "title": "Extending readux"
        },
        {
            "location": "/extending/#extending-readux",
            "text": "This document assumes familiarity with what's written intended\nthe  design overview  and  reference  pages, \nwhich explain the rationale and introduces core terminology.",
            "title": "Extending Readux"
        },
        {
            "location": "/extending/#of-libraries-and-frameworks",
            "text": "readux, like  redux , is a fairly unopinionated  library . \nLibraries are limited in scope whereas frameworks are cohesive, thoughtful, but prescriptive  solutions to a set of problems.\nFrameworks are a great thing when your use-case aligns perfectly with\nwhat the authors intended - less so when you're fighting them to achieve\nsomething not envisioned or catered to.  Conversely, libraries are concerned with solving a relatively small problem\nand you're left to assemble the libraries needed to solve your problem.\nThe upside is that you can tailor a solution matching the problem.  For example, the Redux community has multiple takes on managing async\nrequests, from  thunks  to  promises  through  generators .\nThere is no universal,  right  ( ) solution - the best approach is relative\nto the scale and complexity of your application. \nEven if there were, using a set of libraries means that once some superior\napproach to solving the problem comes along, you can swap out a library\ninstead of starting all over in a new framework.  In summary, readux doesn't do much, but it's designed to play well with\nother libraries, and that's a good thing( ).",
            "title": "Of libraries and frameworks"
        },
        {
            "location": "/extending/#how-to-extend-readux",
            "text": "In concrete terms, readux allows writing  store enhancers  augment the store,\nadding additional functionality like 'queries', debuggers etc and  middleware ,\nwhich sits between the call dispatching an action and it being forwarded to the\nreducer.\nGenerally, if you mean to simply alter actions on a case-by-case (pure) basis,\nmiddleware will do. If you need to retain some state, e.g. to store a map of\nregistered queries or data related to a debugger, then writing a store enhancer\nis the way to go.",
            "title": "How to extend readux"
        },
        {
            "location": "/extending/#middleware",
            "text": "Middleware is used whenever you wish to automatically do something\nbefore an action reaches your store's root reducer or before the\nresulting model is persisted.",
            "title": "Middleware"
        },
        {
            "location": "/extending/#example-handling-promises",
            "text": "Say we wanted to automatically process incoming actions which submits a\npromise as their argument, splitting the action  :fetch-posts  into  :fetch-posts.rq ,  :fetch-posts.success  and  :fetch-posts.error  to signify\nwhen the request is made, and when it ends in a success or an error,\nrespectively. We could wrap this process ourselves for each async request our\napplication would make, or write a piece of middleware to handle promises for us.  Incidentially, if you wish to do this, or already use  promesa ,\ntry  readux-promesa .",
            "title": "Example: Handling Promises"
        },
        {
            "location": "/extending/#example-verifying-app-model-with-cljsspec",
            "text": "Similarly, if you wished to ensure that for each action, the model\nretained some specific structure, you could implement a middleware function\nto validate the resulting model against a clojure.spec schema.",
            "title": "Example: Verifying app model with cljs.spec"
        },
        {
            "location": "/extending/#writing-middleware",
            "text": "Signature:   next -> model, action -> new-model  We see from the signature that middleware takes a single argument ' next ', which\nis the middleware/reducer function to execute next. From this, we get a function,\nwhich, when given a ' model ' and an ' action ', yields a new model which is the\nresult of applying the action to the old model.  ;; This middleware does nothing but pass the action along.\n(defn passthrough-middleware\n  [next]\n  (fn [model action]\n    (apply next model action)))  Often times, you only need to do something to an action or in response to\nan action  before  it is received by the reducer, but sometimes it can\nbe handy to work on the resulting model too.  Readux ships with a middleware function,  log-model-diff  which can show you\nevery action that is dispatched and how it changed the model.  log-model-diff  stores a copy of the model before passing it on to the next\nmiddleware function in the chain, ideally the reducer itself, comparing the \nresulting model to the initial model.\nTry reading its  source \nfor inspiration on writing your own middleware functions.  Remember, middleware functions can:   prematurely abort processing simply by not calling the next function in line.  alter/replace and dispatch additional actions.   (see  readux-promesa  which uses this to handle promises)    alter/replace the input model before passing it on to the next function  alter/replace the new model before returning it to the caller (ultimately the  dispatch  function, which stores the new model)",
            "title": "Writing middleware"
        },
        {
            "location": "/extending/#using-middleware",
            "text": "To use middleware, we supply  store  with an optional second argument\nwhich modifies the construction of the store somehow before it is\nreturned to us.  In this case, using  apply-mw  allows us to install an arbitrary sequence\nof functions in between  dispatch  which first receives and action, and\nthe store's reducer function. Here's an example:  (require '[readux.core :as rdc])\n(require '[readux.store :as rds])\n;; ...\n(defonce store (rdc/store app-reducer (rds/apply-mw some-other-middleware log-model-diff)))  In this case, the action will go through the system like so:   dispatch  this is when the action is first dispatched   some-other-middleware  log_model_diff  app-reducer  - the application's reducer function.",
            "title": "Using middleware"
        },
        {
            "location": "/extending/#store-enhancers",
            "text": "Signature:   store -> store  Store enhancers, as their name implies, modify the store object itself. Generally, store enhancers should be used when\nmiddleware won't suffice, such as when new functionality relying on additional fields in the store object is implemented.",
            "title": "Store enhancers"
        },
        {
            "location": "/extending/#example-readux-debugger",
            "text": "For example, the readux-debugger creates an additional store, tied to the app-store which controls its own model and which\nhas its own reducer. By enhancing the store, it can replace the standard dispatch-function invoked when an action is \ndispatched.\nThe dispatch function normally finds the store's reducer, and passes along the action, storing the value returned as the\nnew model.\nBy replacing the dispatcher, the readux-debugger can intercept and assure that debug-related actions never reach the\napp reducer while ensuring app-related actions are dispatched to both the debugger and app stores.  ( NOTE  not presently released, coming soon)",
            "title": "Example: readux-debugger"
        },
        {
            "location": "/extending/#writing-store-enhancers",
            "text": "The smallest possible example is also a bit silly, typically you want to wrap the  :dispatch  function or add some\nadditional entries to facilitate some expanded interface.  (defn make-stores-great-again\n  [app-store]\n  (swap! app-store assoc :is-great? true))  With our additional data, we can implement new store functions, such as this:  (defn great-store?\n  [store] \n  (get @store :is-great? false))  The ability for a store to use middleware functions is actually implemented as\na store enhancer, see  apply-mw  in  readux store.cljs .",
            "title": "Writing Store Enhancers"
        },
        {
            "location": "/extending/#using-store-enhancers",
            "text": "The store function accepts an additional argument, allowing you to specify an enhancer function.\nTo use multiple store enhancers, use  composition .  (def s (store my-reducer make-stores-great-again))\n(great-store? s)\n;;=> true",
            "title": "Using Store Enhancers"
        },
        {
            "location": "/effective-reagent/",
            "text": "Effective Reagent\n\n\nNot yet done.. Sorry :(",
            "title": "Effective Reagent"
        },
        {
            "location": "/effective-reagent/#effective-reagent",
            "text": "Not yet done.. Sorry :(",
            "title": "Effective Reagent"
        },
        {
            "location": "/tutorial/",
            "text": "Readux Tutorial\n\n\nYea, I'm not that far yet, sorry :(\n\n\nFor now, try to read the \nexample todo application\n.",
            "title": "Tutorial"
        },
        {
            "location": "/tutorial/#readux-tutorial",
            "text": "Yea, I'm not that far yet, sorry :(  For now, try to read the  example todo application .",
            "title": "Readux Tutorial"
        }
    ]
}