{
    "docs": [
        {
            "location": "/",
            "text": "Readux\n\n\nReadux is a \nsmall\n (~100 LOC core before comments & asserts) library for managing state in web \napplications already using \nreagent\n.\n\n\nDocumentation is under construction...\n\n\nThis project is very new and the documentation you see is a first pass - certain examples mentioned in passing\n(handling promises, spec validation, debugger) will become projects in their own right very soon.\n\n\nAlso, if you have a great idea, go ahead and implement it - if it's suitably open (e.g. MIT/BSD), we will\nhappily mention it in these docs :)\n\n\nShort(ish) description\n\n\nReadux aims to simplify state management by encouraging all state to be managed by a \nstore\n which holds a single entity, which we\ncall the \nmodel\n.\n\n\nThe only way to update the model is to dispatch actions against the store. An action is merely a keyword (e.g. \n:ADD-TODO\n)\nand some (optional) data.\nThe point is for the dispatched actions to describe \nwhat happened\n and have the store contain the logic dictating what to \ndo in response to those actions. This way, we hope to encourage the separation of application logic from the presentation.\n\n\nTo actually handle actions, the store takes a \nreducer\n function, named after the function argument to the \n\nreduce\n function, a reducer is a function which, given an\nan accumulated value (the old model) and some new input (the action) produces a new accumulated value.\n\n\nIn short, a reducer basically has the signature \nreducer: model, action -> new-model\n.\n\n\nTo read from the store, we may either use \nstore->model\n to access to the entire model through a \nreaction\n (think read-only atom)\nor write special named functions called \nqueries\n which we can then use in various reagent components\nto extract data from our model.\n\n\nInspiration\n\n\n\n\nredux\n\n\nThe introduction to reactive programming you've been missing\n\n\nre-frame\n\n\nREADME\n\n\nWIKI: When do components update?\n\n\n\n\n\n\nElm (Lang)\n\n\nElm Tutorial",
            "title": "Home"
        },
        {
            "location": "/#readux",
            "text": "Readux is a  small  (~100 LOC core before comments & asserts) library for managing state in web \napplications already using  reagent .",
            "title": "Readux"
        },
        {
            "location": "/#documentation-is-under-construction",
            "text": "This project is very new and the documentation you see is a first pass - certain examples mentioned in passing\n(handling promises, spec validation, debugger) will become projects in their own right very soon.  Also, if you have a great idea, go ahead and implement it - if it's suitably open (e.g. MIT/BSD), we will\nhappily mention it in these docs :)",
            "title": "Documentation is under construction..."
        },
        {
            "location": "/#shortish-description",
            "text": "Readux aims to simplify state management by encouraging all state to be managed by a  store  which holds a single entity, which we\ncall the  model .  The only way to update the model is to dispatch actions against the store. An action is merely a keyword (e.g.  :ADD-TODO )\nand some (optional) data.\nThe point is for the dispatched actions to describe  what happened  and have the store contain the logic dictating what to \ndo in response to those actions. This way, we hope to encourage the separation of application logic from the presentation.  To actually handle actions, the store takes a  reducer  function, named after the function argument to the  reduce  function, a reducer is a function which, given an\nan accumulated value (the old model) and some new input (the action) produces a new accumulated value.  In short, a reducer basically has the signature  reducer: model, action -> new-model .  To read from the store, we may either use  store->model  to access to the entire model through a  reaction  (think read-only atom)\nor write special named functions called  queries  which we can then use in various reagent components\nto extract data from our model.",
            "title": "Short(ish) description"
        },
        {
            "location": "/#inspiration",
            "text": "redux  The introduction to reactive programming you've been missing  re-frame  README  WIKI: When do components update?    Elm (Lang)  Elm Tutorial",
            "title": "Inspiration"
        },
        {
            "location": "/design/",
            "text": "Design\n\n\nOverview\n\n\nTerminology\n\n\nOf libraries and frameworks\n\n\nReadux, like \nRedux\n, is a fairly unopinionated \nlibrary\n. \nLibraries are limited in scope whereas frameworks are cohesive, thoughtful, but\n\nprescriptive\n solutions to a set of problems.\nFrameworks are a great thing when your use-case aligns perfectly with\nwhat the authors intended - less so when you're fighting them to achieve\nsomething not envisioned or catered to.\n\n\nConversely, libraries are concerned with solving a relatively small problem\nand you're left to assemble the libraries needed to solve your problem.\nThe upside is that you can tailor a solution matching the problem.\n\n\nFor example, the Redux community has multiple takes on managing async\nrequests, from \nthunks\n to \n\npromises\n through \n\ngenerators\n.\nThere is no universal, \nright\n (\n) solution - the best approach is relative\nto the scale and complexity of your application. \nEven if there were, using a set of libraries means that once some superior\napproach to solving the problem comes along, you can swap out a library\ninstead of starting all over in a new framework.\n\n\nIn summary, Readux doesn't do much, but it's designed to play well with\nother libraries, and that's a good thing(\n).",
            "title": "Design"
        },
        {
            "location": "/design/#design",
            "text": "",
            "title": "Design"
        },
        {
            "location": "/design/#overview",
            "text": "",
            "title": "Overview"
        },
        {
            "location": "/design/#terminology",
            "text": "",
            "title": "Terminology"
        },
        {
            "location": "/design/#of-libraries-and-frameworks",
            "text": "Readux, like  Redux , is a fairly unopinionated  library . \nLibraries are limited in scope whereas frameworks are cohesive, thoughtful, but prescriptive  solutions to a set of problems.\nFrameworks are a great thing when your use-case aligns perfectly with\nwhat the authors intended - less so when you're fighting them to achieve\nsomething not envisioned or catered to.  Conversely, libraries are concerned with solving a relatively small problem\nand you're left to assemble the libraries needed to solve your problem.\nThe upside is that you can tailor a solution matching the problem.  For example, the Redux community has multiple takes on managing async\nrequests, from  thunks  to  promises  through  generators .\nThere is no universal,  right  ( ) solution - the best approach is relative\nto the scale and complexity of your application. \nEven if there were, using a set of libraries means that once some superior\napproach to solving the problem comes along, you can swap out a library\ninstead of starting all over in a new framework.  In summary, Readux doesn't do much, but it's designed to play well with\nother libraries, and that's a good thing( ).",
            "title": "Of libraries and frameworks"
        },
        {
            "location": "/extending/",
            "text": "Extending Readux\n\n\nThis document assumes familiarity with what's written intended\n\nthe design\n, which explains the rationale and introduces core\nterminology.\n\n\nIn general, Readux is intended to be extended through middleware and store\nenhancers, both of which are described below.\n\n\nMiddleware\n\n\nMiddleware is used whenever you wish to automatically do something\nbefore an action reaches your store's root reducer or before the\nresulting model is persisted.\n\n\nExample: Handling Promises\n\n\nSay we wanted to automatically process incoming actions which submits a\npromise as their argument, splitting the action \n:FOO\n into \n:FOO/PENDING\n\n\n:FOO/SUCCESS\n and \n:FOO/FAILURE\n to signify when the request is made,\nand when it ends in a success or an error, respectively.\nWe could wrap this process ourselves for each async request our application\nwould make, or write a piece of middleware to handle promises for us.\n\n\nExample: Verifying app model with cljs.spec\n\n\nSimilarly, if you wished to ensure that for each action, the model\nretained some specific structure, you could implement a middleware function\nto validate the resulting model against a clojure.spec schema.\n\n\nWriting middleware\n\n\nSignature:\n \nnext -> model, action [, args ...] -> new-model\n\n\nWe see from the signature that middleware takes a single argument '\nnext\n', which\nis the middleware/reducer function to execute next. From this, we get a function,\nwhich, when given a '\nmodel\n', an '\naction\n' (and optionally some '\nargs\n'),\nyields a new model which is the result of applying the action to the old model.\n\n\n;; This middleware does nothing but pass the action along.\n(defn passthrough-middleware\n  [next]\n  (fn [model action & args]\n    (apply next model action args)))\n\n\n\n\nUsing middleware\n\n\nMiddleware is used by composing it with your application's reducer using \ncomposition (\ncomp\n)\n\nor the \nthreading macro (\n->\n)\n threading macro.\n\n\nYou can express the order of execution in whichever way feels the most natural:\n\n\n((-> my-reducer baz bar foo) ...)\n;;execution order: foo, bar, baz, my-reducer\n\n(((comp baz bar foo) my-reducer) ...)\n;; execution order: baz, bar, foo, my-reducer\n\n\n\n\nStore enhancers\n\n\nSignature:\n \nstore -> store\n\n\nStore enhancers, as their name implies, modify the store object itself. Generally, store enhancers should be used when\nmiddleware won't suffice, such as when new functionality relying on additional fields in the store object is implemented.\n\n\nExample: readux-debugger\n\n\nFor example, the readux-debugger creates an additional store, tied to the app-store which controls its own model and which\nhas its own reducer. By enhancing the store, it can replace the standard dispatch-function invoked when an action is \ndispatched.\nThe dispatch function normally finds the store's reducer, and passes along the action, storing the value returned as the\nnew model.\nBy replacing the dispatcher, the readux-debugger can intercept and assure that debug-related actions never reach the\napp reducer while ensuring app-related actions are dispatched to both the debugger and app stores.\n\n\nWriting Store Enhancers\n\n\nThe smallest possible example is also a bit silly, typically you want to wrap the \n:dispatch\n function or add some\nadditional entries to facilitate some expanded interface.\n\n\n(defn make-stores-great-again\n  [app-store]\n  (swap! app-store assoc :is-great? true))\n\n\n\n\nWith our additional data, we can implement new store functions, such as this:\n\n\n(defn great-store?\n  [store] \n  (get @store :is-great? false))\n\n\n\n\nUsing Store Enhancers\n\n\nThe store function accepts an additional argument, allowing you to specify an enhancer function.\nTo use multiple store enhancers, use \ncomposition\n.\n\n\n(def s (store my-reducer make-stores-great-again))\n(great-store? s)\n;;=> true",
            "title": "Extending"
        },
        {
            "location": "/extending/#extending-readux",
            "text": "This document assumes familiarity with what's written intended the design , which explains the rationale and introduces core\nterminology.  In general, Readux is intended to be extended through middleware and store\nenhancers, both of which are described below.",
            "title": "Extending Readux"
        },
        {
            "location": "/extending/#middleware",
            "text": "Middleware is used whenever you wish to automatically do something\nbefore an action reaches your store's root reducer or before the\nresulting model is persisted.",
            "title": "Middleware"
        },
        {
            "location": "/extending/#example-handling-promises",
            "text": "Say we wanted to automatically process incoming actions which submits a\npromise as their argument, splitting the action  :FOO  into  :FOO/PENDING  :FOO/SUCCESS  and  :FOO/FAILURE  to signify when the request is made,\nand when it ends in a success or an error, respectively.\nWe could wrap this process ourselves for each async request our application\nwould make, or write a piece of middleware to handle promises for us.",
            "title": "Example: Handling Promises"
        },
        {
            "location": "/extending/#example-verifying-app-model-with-cljsspec",
            "text": "Similarly, if you wished to ensure that for each action, the model\nretained some specific structure, you could implement a middleware function\nto validate the resulting model against a clojure.spec schema.",
            "title": "Example: Verifying app model with cljs.spec"
        },
        {
            "location": "/extending/#writing-middleware",
            "text": "Signature:   next -> model, action [, args ...] -> new-model  We see from the signature that middleware takes a single argument ' next ', which\nis the middleware/reducer function to execute next. From this, we get a function,\nwhich, when given a ' model ', an ' action ' (and optionally some ' args '),\nyields a new model which is the result of applying the action to the old model.  ;; This middleware does nothing but pass the action along.\n(defn passthrough-middleware\n  [next]\n  (fn [model action & args]\n    (apply next model action args)))",
            "title": "Writing middleware"
        },
        {
            "location": "/extending/#using-middleware",
            "text": "Middleware is used by composing it with your application's reducer using  composition ( comp ) \nor the  threading macro ( -> )  threading macro.  You can express the order of execution in whichever way feels the most natural:  ((-> my-reducer baz bar foo) ...)\n;;execution order: foo, bar, baz, my-reducer\n\n(((comp baz bar foo) my-reducer) ...)\n;; execution order: baz, bar, foo, my-reducer",
            "title": "Using middleware"
        },
        {
            "location": "/extending/#store-enhancers",
            "text": "Signature:   store -> store  Store enhancers, as their name implies, modify the store object itself. Generally, store enhancers should be used when\nmiddleware won't suffice, such as when new functionality relying on additional fields in the store object is implemented.",
            "title": "Store enhancers"
        },
        {
            "location": "/extending/#example-readux-debugger",
            "text": "For example, the readux-debugger creates an additional store, tied to the app-store which controls its own model and which\nhas its own reducer. By enhancing the store, it can replace the standard dispatch-function invoked when an action is \ndispatched.\nThe dispatch function normally finds the store's reducer, and passes along the action, storing the value returned as the\nnew model.\nBy replacing the dispatcher, the readux-debugger can intercept and assure that debug-related actions never reach the\napp reducer while ensuring app-related actions are dispatched to both the debugger and app stores.",
            "title": "Example: readux-debugger"
        },
        {
            "location": "/extending/#writing-store-enhancers",
            "text": "The smallest possible example is also a bit silly, typically you want to wrap the  :dispatch  function or add some\nadditional entries to facilitate some expanded interface.  (defn make-stores-great-again\n  [app-store]\n  (swap! app-store assoc :is-great? true))  With our additional data, we can implement new store functions, such as this:  (defn great-store?\n  [store] \n  (get @store :is-great? false))",
            "title": "Writing Store Enhancers"
        },
        {
            "location": "/extending/#using-store-enhancers",
            "text": "The store function accepts an additional argument, allowing you to specify an enhancer function.\nTo use multiple store enhancers, use  composition .  (def s (store my-reducer make-stores-great-again))\n(great-store? s)\n;;=> true",
            "title": "Using Store Enhancers"
        },
        {
            "location": "/tutorial/",
            "text": "Readux Tutorial\n\n\nYea, I'm not that far yet, sorry :(\n\n\nFor now, try to read the example in \nexamples/todo\n.",
            "title": "Tutorial"
        },
        {
            "location": "/tutorial/#readux-tutorial",
            "text": "Yea, I'm not that far yet, sorry :(  For now, try to read the example in  examples/todo .",
            "title": "Readux Tutorial"
        }
    ]
}